# 操作系统的基本原理

## 操作体系概论

### 1.1 操作系统的定义

应用程序->实用程序->操作系统->硬件

**单向调用的关系**

### 1.2 操作系统的形成与发展

**顺序处理、简单的批处理**

多道批处理系统：以主存为中心，与CPU相连，用通道与I/O设备相连，存放多个作业，在主存中同时存放多个作业，根本目的是提高PCU的利用率，充分发挥并行性。通过资源利用率（实际使用时间/给定时间）、吞吐量（单位时间内系统处理的信息量）、周转时间（作业进入系统到退出系统所经历的时间）

批处理系统使用多道程序技术后，存在问题：不能直接控制作业运行、作业的周转时间长，提出了分时系统

**分时系统**：将CPU单位时间划分为多个时间片，分时系统具有的特点是：同时性（若干个终端同时使用计算机）、独立性（各个用户独立占有一台终端）、交互性（与用户交互）、及时性（用户的请求能够在短时间得到响应）

**实时系统**：实时性（响应时间要求严格）、可靠性（要求软硬件高可靠）、确定性（系统内核保证系统尽可能快响应外部事件）

### 1.3 操作系统的功能、服务和特性

**操作系统的功能**：处理机管理、存储器管理、设备管理、文件管理

**操作系统提供的服务**：用户接口、执行程序、I/O操作、文件操作、通信服务、资源分配、错误检测等

**操作系统的特性**：并发性（同时处在活动状态的相互独立的程序竞争系统各种资源）、共享性（分配调度资源）、虚拟性（把物理实体资源变为逻辑上的对应物）、异步性（进程之间相互制约关系）

### 1.4 操作系统的进一步发展

个人操作系统-》多处理机操作系统-〉网络操作系统-》分布式操作系统

### 1.5 用户与操作系统的接口

两种接口：一种是提供给操作计算机的用户的操作接口、另一种是提供给编程人员使用的低级接口

**用户与操作系统的操作接口**：1. 命令解释程序（以命令行的形式，通过命令解释程序解释执行，如shell；命令解释程序有两种实现方法：（1）本身包含了执行这些命令的代码；（2）操作系统核心实现命令要求的功能）。2. 图形用户接口。 3. 作业运行的控制命令（批处理系统和分时系统）：解释执行的脱机控制命令（负责的是命令解释程序），或者是交互式的作业控制命令

**系统调用接口**：处理机在处理机状态字中增加一个执行方式位，区分用户态和核心态，处理机的执行状态决定了所能进行的操作（1. 执行指令的特权性 2. 存储器访问的特权性）

系统调用的功能：进程控制、文件管理、设备管理等

用户程序执行到途中的时候，遇到系统调用的时候，切换到核心态，然后操作系统内核执行核心态代码，进行系统调用命令程序，结束后再返回到用户态。

导致切换的两个原因：中断、异常

系统调用的执行过程：1. 通过中断、异常使系统切换到核心态，CPU进入核心态，按照特权的方式运行。 2. 将程序计数器和处理机的当前状态存入任务的堆栈中。3. 将系统调用号存入核心堆栈中。4. 执行汇编代码来保存通用寄存器中的内容。5. 调用相应的操作系统例程来完成系统调用。6. 返回到用户方式

### 1.6 操作系统的运行环境

**中断**：是一些外部设备向CPU放出的一个硬件信号，如外部设备的I/O完成中断、时钟中断等，和当前执行的指令无关，是异步发生的，而且是可以被屏蔽的。当中断产生的时候，CPU响应中断，转入对应的中断处理程序执行

**异常**：也叫做陷入，是执行程序自己产生的，是同步发生的，而且是不可屏蔽的。产生条件是：1. 程序错误如程序非法操作码、地址越界、除数为0，存储器管理中的页面失效等；2. 由于程序请求操作系统服务和请求系统资源等使用系统调用。

**除了内核少部分代码再核心态运行以外，大部分操作系统功能以独立系统进程运行在用户态，这就是微内核操作系统**

### 1.7 操作系统的设计规范与结构设计

略

## 进程管理

### 2.1 进程的引入和概念

**程序的并行执行**：（1）失去了程序的封闭性和可再现性（资源是共享的而非独占）（2）并行执行的程序之间产生了相互制约的关系（3）程序与CPU执行的活动之间不再一一对应。

**进程**：（1）是程序的一次执行过程；（2）是程序在一个数据集合上顺序执行时发生的活动。它是系统进行资源分配和调度的独立单位。

**进程和程序**：1. 进程是程序的一次执行，具有动态性；2. 晋城市系统进行资源分配的一个独立单位，具有独立性，而程序则不是，资源分配是以进程为单位的，而不是以程序为单位的；3. 一个进程可以与其他进程并发执行，具有并发性；4. 进程具有结构性。为描述进程的运行变化过程，系统为每一个进程都要建立一个结构——进程控制块。从结构上看，进程是由程序、数据和进程控制块三部分组成的。

**线程**就是处理机调度的基本对象，就是减少程序并发执行时系统付出的时间空间开销，使得系统的运行更加有效。而进程是只作为除CPU外的系统资源的分配对象。进程是指完成一个作业，而线程就是完成作业的许多可能的字任务，线程是进程中的一个可执行实体，是被操作系统调度的一个独立单位，一个进程可以有多个线程的，多线程共享进程的所有资源。

### 2.2 进程的描述

**进程控制块PCB（也叫进程描述符PD）**：描述进程的运行变化情况，操作系统为每个进程定义的数据结构。

PCB包括：1.进程标识数：进程的唯一标识，一般为整数；2. 进程的状态以及调度和存储器管理信息（进程状态、进程优先级、程序在主存的入口地址、在外存的地址、信息允许的存取保护方式）；3. 进程使用的资源信息（分配给进程的I/O设备、当前进程打开的文件等）；4. CPU现场保护区（进程挂起的时候就放在这里，等待下次调度运行的时候恢复现场继续运行，通常CPU的现场信息包括：程序计数器、程序状态字PSW、通用寄存器、堆栈指针等）；5. 记账信息：使用的CPU的时间量、账号等；6. 进程之间的家族关系：记录本进程的父进程是谁、子进程是谁；7. 进程的链接指针：用于将相同状态的进程链接在一起

**进程的状态**：1. 创建态、终止态、就绪态、运行态、等待态；2. 就绪态的通过进程调度变为运行态；3. 运行态的进程主动改变，比如启动了I/O设备，使得自己变成了等待态，等待I/O完成；4. 等待态由于外界事件引起编程就绪态，比如I/O完成时候的请求中断；5. 处于运行态的进程被剥夺CPU时引起的，比如时间片用完了，或者优先级调度的时候有更高优先级的进程变为就绪态，那么当前进程就被迫放弃CPU，使自己变成就绪态，之后转处理机调度。

**进程的组织**：不同的进程有着不同的状态，而系统需要对每个进程进行统一管理，因此出现了进程的组织管理问题

（1）线性表：将所有进程的PCB组成一个数组，系统通过数组下标访问每一个PCB。优点是简单、节省存储空间，缺点是系统查找开销大，早期UNIX系统采用。

（2）链接表：处于同一状态的进程PCB按照一定方式链接成一个队列，每一个队列有一个专用队列指针指出该队列中第一个PCB的位置。形成了就绪队列、等待队列。各种进程可以按照某种策略排成多个队列，比如等待磁盘I/O队列、等待磁带I/O队列等。

在单CPU中任何时刻只有一个进程处于运行状态，因此系统专门设置一个指针指向当前运行进程的PCB。UNIX系统中就有一个CURPRO指针，指向当前运行的进程的PCB

### 2.3 进程的控制

进程控制是由不允许被中断的程序，或叫其执行过程不可分割的原语实现的。

1. **创建原语**：扫描系统PCB结合表，找到空闲的PCB，并获得该PCB的内部名称作为标识符。若进程的程序和数据等不在主存，也要去分配主存，并调入主存，然后把调用者提供的参数：进程名、优先级、实体所在主存的起始位置等填入PCB结构，并将进程状态设置为就绪状态，插入就绪队列中。

2. **撤销原语**：（进程已经完成任务或者由于故障无法继续运行，需要让进程控制块从系统中消失）在PCB集合中找到所要撤销的进程，若找到，检查该进程是否有子进程，若有，则递归进去，将子进程所占用资回收给系统，并撤销子进程的控制块。之后把进程的资源还给系统，撤销PCB。
3. **阻塞原语**：处于运行态的进程中断CPU，将其运行现场保存在PCB中，将状态设置为阻塞，然后插入对应事件的等待队列中，最后转处理机调度。
4. **唤醒原语**：情况一：等待I/O完成时，硬件提出中断请求，CPU响应中断，暂停当前进程的执行，进行中断处理，检查队列中的等待着，将其唤醒，放入就绪态。结束中断处理，要么返回被中断进程继续执行，要么转处理机调度，重新选择进程投入运行；情况二：事件是等待某进程发一个信息，当信息发送给该等待进程的时候，由发送进程把该等待者唤醒，并设置为就绪态，插入就绪队列。
5. **挂起原语**：如果是分时系统中，假设是进程时间片用完，从主存换到磁盘中的时候，进程就处于静止就绪状态；假设是阻塞进程从主存调出到磁盘，它由活动阻塞的变为禁止阻塞。这就是挂起。
6. **解挂原语**：如上对应关系

### 2.4 处理机的调度

**处理机调度的级别**：**（1）高级调度，也叫作业调度**，一般是多道批处理系统而非分时系统，通常将IO量大的和CPU量大的作业结合在一起进行调度，控制作业进入内存的个数；**（2）低级调度，也叫进程调度**，进程调度是比较频繁的，控制CPU的利用；**（3）交换调度**，充分利用系统资源，将处于主存就绪或主存阻塞的进程换到外存交换区，将外存中就绪状态具备运行条件的进程换到主存。

**进程调度**：也叫处理机调度，按照某种算法把CPU动态地分配给某一就绪进程的过程，通过处理机调度程序来完成，主要功能描述如下：（1）管理系统中各个进程的的执行状况，通过PCB变化掌握的；（2）选择进程去占有CPU；（3）进行进程上下文的切换，进程的上下文是指操作系统为运行进程设置的对应的运行环境和进程的物理实体，由用户级（进程中的程序和数据）、寄存器级（CPU现场信息）、系统级（进程控制块、进程运行时的系统环境，进程状态、存储器管理）的上下文组成。

**进程调度的方式**：非抢先方式（只有到不能执行的时候才会调度，对于紧急任务及时处理的情况无法做到）、抢先方式（更多用在分时系统、实时系统、多任务操作系统）

**进程调度的时机**：1. 现行进程执行出现错误中止运行；2. 进程提出IO请求；3. 分时系统时间片用完；4. 优先级调度下，更高优先级的进程就绪了；5. 进程执行了阻塞原语、唤醒原语也可能引起。

**处理机调度算法**：（1）FCFS，先来先服务；（2）最短作业的进程优先调度：长进程会饿死；（3）响应比高优先：响应比=1+（作业等待时间/作业估计运行时间）；（4）优先级调度法：静态优先级创建时确定；动态优先级可根据占用CPU时间长短、等待时间等进行调配；（5）轮转法：分时系统中，轮流调度；实现的时候利用一个定时时钟，发出中断。（6）多级反馈队列轮转法：有很多个队列，几个队列采用前后台运行，前台队列采用轮转法调度，后台队列采用先来先服务法调度。前台进程优先级高于后台进程，前台各种队列优先级也不一样，高优先级队列时间片短，低优先级队列时间片长。（比如刚创建的进程、因请求IO未用完时间片的进程排在最高优先级队列）系统调度时候，按照优先级高去调度，当队列为空才调度次优先级的，不论什么时候，只要高优先级队列有进程进入，立刻转处理机调度，及时调度高优先级队列的进程。



对于实时系统有下面的算法：

**时钟驱动法**：硬实时系统的任务所有参数固定且可知，常用的选择就是以规则的间隔时间进行调度决策

**加权轮转法**：与轮转法不同，进程给予不同的权值，中途可调整

### 2.5 线程的引入

线程就是处理机调度的基本对象，就是减少程序并发执行时系统付出的时间空间开销，使得系统的运行更加有效。而进程是只作为除CPU外的系统资源的分配对象。进程是指完成一个作业，而线程就是完成作业的许多可能的字任务，线程是进程中的一个可执行实体，是被操作系统调度的一个独立单位，一个进程可以有多个线程的，多线程共享进程的所有资源。

线程控制块：（1）唯一的标识符；（2）有表示处理机状态和运行现场的一组寄存器，CPU现场信息；（3）两个堆栈，用于用户态和核心态调用时的参数传递；（4）又一个独立的程序计数器，或叫做一个私有的存储区；（5）关联的进程和线程指针。

<img src="../assets/image-20210101025253485.png" alt="image-20210101025253485" style="zoom:15%;" />

系统对线程的支持：

（1）用户级线程：指有关管理线程的工作都由用户程序通过调用用户态运行的线程库来完成，系统内核并不知道线程的存在。应用程序根据需要，在同一个进程中创建线程，自己设计带哦度算法调度线程运行，由于内核是单线程，所以任何一个用户级线程的阻塞，都会导致进程的阻塞。用户态的多线程对应核心态的一个线程或进程。

用同步的方式写异步的代码，让读代码写代码的人皆大欢喜。

开销小

（2）核心级线程：线程管理工作交给系统内核，用户应用程序通过调用线程的应用程序编程接口API来管理线程。用户态的一个线程对应核心态的一个线程或进程。对创建线程的数量有限制。

（3）两级组合：略



## 进程并发控制与死锁

### 3.1 并发进程的特点

### 3.2 进程之间的低级通信

### 3.3 管程

### 3.4 进程的高级通信

### 3.5 死锁

## 存储器管理

### 4.1 概述

### 4.2 单用户单道程序的存储器管理

### 4.3 多用户多道程序的存储器分配——分区分配

### 4.4 覆盖和交换技术

### 4.5 页式存储器管理

### 4.6 段式存储器管理

### 4.7 虚拟存储器管理

## 文件系统

### 5.1 文件和文件系统

### 5.2 文件目录结构

### 5.3 文件的逻辑结构和存取方法

### 5.4 文件的物理结构和存储介质

### 5.5 文件记录的组块与分解

### 5.6 文件存储器存储空间的管理

### 5.7 文件的共享与保护

### 5.8 文件的操作命令

### 5.9 文件系统的组织结构

### 5.10 存储器映射文件

## 设备管理

### 6.1 I/O硬件组成

### 6.2 I/O软件的组成

### 6.3 磁盘管理

# Linux操作系统

## Linux进程管理

### 7.1 Linux进程的组成

### 7.2 Linux进程链表

### 7.3 Linux进程控制

### 7.4 Linux进程切换

### 7.5 Linux进程调度

### 7.6 内核同步

## Linux存储器管理

### 8.1 进程地址空间的分配

### 8.2 物理内存管理

### 8.3 slab管理

### 8.4 高端内存区管理

### 8.5 地址转换

### 8.6 请求调页与缺页异常处理

### 8.7 盘交换区空间管理

## Linux文件系统

### 9.1 Ext2的磁盘涉及的数据结构

### 9.2 Ext2的主存数据结构

### 9.3 Ext2磁盘空间管理

### 9.4 Ext2提供的文件操作

## Linux虚拟文件系统

### 10.1 虚拟文件系统涉及的数据结构

### 10.2 文件系统的注册和安装

### 10.3 VFS系统调用的实现

## Linux I/O系统

### 11.1 设备驱动模型

### 11.2 设备文件

### 11.3 设备驱动程序

### 11.4 高速缓存

## 中断、异常、信号处理

### 12.1 中断和异常处理的硬件基础

### 12.2 中断和异常处理

### 12.3 信号处理机制

## UNIX系统进程间通信

### 13.1 管道通信

### 13.2 UNIX系统V的交互进程通信

### 13.3 信号量机制

### 13.4 消息缓冲机制

### 13.5 共享内存区机制