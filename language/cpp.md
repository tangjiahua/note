# 第四章：复合类型

面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。

在运行阶段做决策并非OOP独有的，但使用C++编写这样的代码比使用C语言简单。

int *p1, p2;	// 对于每一个指针变量名，都需要一个星号。

C++中，int*是一种复合类型，是指向int类型的指针。

一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。

```c++
int *pt;
pt = 0xB8000000;	// type mismatch
pt = (int *)0xB8000000;	//type match
```

在C99标准发布之前，C语言允许这样赋值。但C++在类型一致方面的要求更严格，编译器将显示一条错误消息，通告类型不匹配。

指针的真正用武之地子啊雨，在运行阶段分配未命名的内存以存储值。

```c++
int *pn = new int;	// pn指向的内存不是变量

int higgens;
int *pt = &higgens;	//pt指向的内存是变量	
```

C++提供了检测并处理内存分配失败的工具。

只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。

用new分配内存之后，程序确实跟踪了分配的内存量，以便以后使用delete []运算符的时候能够正确的释放这些内存。但这种信息不是公用的，例如，不能使用sizeof运算符来确定动态分配的数组包含的字节数。

```c++
double *p3 = new double [3];
p3 = p3 + 1;	// wrong! this is ok for pointers, but not ok for array names, because it's const;
```

**对数组取地址的时候，数组名也不会被解释为其地址。数组名被解析成为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址！例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度（单位为字节）**// 数组名是一个复合类型，不要简单的把它当成一个指针！

```c++
是个指针 -> short (*pas)[20]; -> 指向长度为20 的数组的指针
是个数组 -> shor *pas [20]; -> 指向一个数组，该数组是关于short指针的数组
```

数组退化为指针：数组名只在同一个栈空间拥有数组特性，不同栈空间中是指向首地址的普通指针。

```c++
tacos[0] means *tacos
tacos[3] means *(tacos+3)
```

